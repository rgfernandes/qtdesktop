* create db
* create tables
* load
* decorate
* sort
* load recurse
* navigate (dive in/up)
* del
* add (files/folders)
- extract

= fixme =
- dclick tries to edit
- db from stratch
- reload db on start
- index arch fields
- foldercache => db
- __addresstack => current_root + parent_id
- sql scheme: id autoinc off
- sql scheme: uniq parent_id + name
- iterator for helper.list()
- iterator for helper.extract()'s fpaths

= test arcivers =
== who ==
7za, [un]arj, [un]zip, tar, lzh, rar, zoo, iso, cpio (rpm), ace, cab, [l]paq
== what ==
* list
* test
* del
* [mkdir]
* mv
* extract:
	* recursive/full
	* skip(files/all)/update/replace
* pack (recursive):
	* to root/subfolder
	* skip/update/replace
	* volumes
	* solid
	* compression levels
	* compression methods
= Add =
* list src (everything, mark enpoints - files and empty dirs)
* check files<>folders
* warning on exists
* if u/r:
	- as is (u/a)
* else:
	- del exists or not endpoints
	- add rest
= Extract =
extract to: 7za e test.7z 11.txt -ottt
* db: добавить поля: arch.endpoint:bool, arch.mark:int (0 - not, 1 - extract (exists), 2 - notexists (extract anyway))
+ после загрузки - отметить endpoint: (все - endpoint => всехние папы - not endpoint)
* составить список распакуемого (mark? cascade on selected IDs)
* проверить exists (endpoint & mark => QFileInfo.exists() => mark=1)
* если skip - убрать exists
* если похер - распаковать
(в любом случае - -o для каждого)

another way:
+ insert into fs selected (id in ...)
+ insert into fs fullpath starts with fs.fullpath + "/"
+ remove not endpoints
* foreach:
	- check exists
	- and mark file/dir
* check dir<>file

= misc =
7z x *.zip -o* (extracts all *.zip archives to subfolders with names of these archives)
